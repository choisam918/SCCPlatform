# 3D展览馆功能详细设计

## 一、3D功能概述

3D虚拟展览馆是本系统的**核心功能**，使用WebGL和Three.js技术创建沉浸式的3D展览体验，让用户仿佛在真实的展览馆中浏览照片。

---

## 二、技术架构

### 2.1 核心技术栈

```
3D展览馆技术栈
├── WebGL
│   └── 底层3D图形渲染API
│
├── Three.js (核心框架)
│   ├── Scene (场景)
│   ├── Camera (相机)
│   ├── Renderer (渲染器)
│   ├── Geometry (几何体)
│   ├── Material (材质)
│   └── Texture (纹理)
│
├── OrbitControls
│   └── 相机轨道控制器
│
└── TextureLoader
    └── 纹理/图片加载器
```

### 2.2 文件结构

```
js/
├── 3d-gallery.js          # 3D展览馆核心文件
│   ├── initScene()        # 初始化场景
│   ├── createWalls()     # 创建墙面
│   ├── createFrames()     # 创建相框
│   ├── loadPhotos()       # 加载照片
│   ├── setupControls()    # 设置控制器
│   └── animate()          # 渲染循环
│
└── libs/
    ├── three.min.js       # Three.js核心库
    └── OrbitControls.js   # 相机控制器
```

---

## 三、3D场景设计

### 3.1 场景结构

```
3D展览馆场景
│
├── 环境
│   ├── 地面 (PlaneGeometry)
│   ├── 天花板 (可选)
│   └── 背景色/天空盒
│
├── 光照系统
│   ├── AmbientLight (环境光)
│   │   └── 提供基础照明
│   ├── DirectionalLight (方向光)
│   │   └── 模拟太阳光/主光源
│   └── PointLight (点光源，可选)
│       └── 局部照明
│
├── 展览空间
│   ├── 主展厅
│   │   ├── 前墙 (Front Wall)
│   │   ├── 左墙 (Left Wall)
│   │   ├── 右墙 (Right Wall)
│   │   └── 后墙 (Back Wall)
│   │
│   └── 侧展厅 (可选)
│       └── 多个小房间
│
└── 照片对象
    ├── 相框 (Frame Mesh)
    ├── 照片纹理 (Photo Texture)
    └── 交互区域 (Interactive Area)
```

### 3.2 场景尺寸设计

```javascript
// 建议尺寸（可根据需要调整）
场景尺寸：
- 房间宽度：20-30单位
- 房间深度：15-25单位
- 房间高度：8-12单位
- 墙面高度：6-8单位

照片尺寸：
- 相框宽度：2-3单位
- 相框高度：1.5-2.5单位（根据照片比例）
- 相框厚度：0.1单位
- 照片间距：0.5-1单位
```

---

## 四、照片挂墙算法

### 4.1 布局策略

#### 策略1：均匀网格布局
```
墙面布局示例：
┌─────────────────────────┐
│ [照片1] [照片2] [照片3]   │
│ [照片4] [照片5] [照片6]   │
│ [照片7] [照片8] [照片9]   │
└─────────────────────────┘
```

#### 策略2：自适应布局
- 根据照片数量自动调整行列数
- 保持照片间距均匀
- 照片居中排列

#### 策略3：多墙面分配
```
照片分配算法：
1. 计算总照片数
2. 计算每面墙可容纳的照片数
3. 按顺序分配照片到各墙面
4. 每面墙独立布局
```

### 4.2 位置计算算法

```javascript
// 伪代码示例
function calculatePhotoPositions(photoCount, wallWidth, wallHeight) {
    // 计算行列数
    const cols = Math.ceil(Math.sqrt(photoCount));
    const rows = Math.ceil(photoCount / cols);
    
    // 计算间距
    const photoWidth = 2.5;
    const photoHeight = 2.0;
    const spacing = 0.5;
    
    const totalWidth = cols * photoWidth + (cols - 1) * spacing;
    const totalHeight = rows * photoHeight + (rows - 1) * spacing;
    
    // 计算起始位置（居中）
    const startX = -totalWidth / 2 + photoWidth / 2;
    const startY = totalHeight / 2 - photoHeight / 2;
    
    // 生成位置数组
    const positions = [];
    for (let i = 0; i < photoCount; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        positions.push({
            x: startX + col * (photoWidth + spacing),
            y: startY - row * (photoHeight + spacing),
            z: 0.1  // 稍微突出墙面
        });
    }
    
    return positions;
}
```

---

## 五、交互控制设计

### 5.1 相机控制（OrbitControls）

#### 桌面端控制
- **鼠标左键拖拽**：旋转视角（围绕场景中心）
- **鼠标滚轮**：缩放（拉近/拉远）
- **鼠标右键拖拽**：平移视角（可选）
- **双击**：聚焦到点击位置（可选）

#### 移动端控制
- **单指拖拽**：旋转视角
- **双指捏合**：缩放
- **双指拖拽**：平移视角

### 5.2 相机设置

```javascript
// 相机初始位置和参数
const camera = new THREE.PerspectiveCamera(
    75,                          // 视野角度 (FOV)
    window.innerWidth / window.innerHeight,  // 宽高比
    0.1,                         // 近裁剪面
    1000                         // 远裁剪面
);

// 初始相机位置
camera.position.set(0, 5, 15);   // (x, y, z)
camera.lookAt(0, 0, 0);          // 看向场景中心

// OrbitControls设置
controls.target.set(0, 2, 0);     // 控制中心点
controls.enableDamping = true;    // 启用阻尼（平滑）
controls.dampingFactor = 0.05;    // 阻尼系数
controls.minDistance = 5;         // 最小距离
controls.maxDistance = 50;        // 最大距离
controls.maxPolarAngle = Math.PI / 2;  // 限制垂直旋转角度
```

### 5.3 照片点击交互

#### 射线检测（Raycasting）
```javascript
// 检测鼠标点击的3D对象
function onMouseClick(event) {
    // 计算鼠标在3D空间中的位置
    const mouse = new THREE.Vector2();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // 创建射线
    raycaster.setFromCamera(mouse, camera);
    
    // 检测相交对象
    const intersects = raycaster.intersectObjects(photoFrames);
    
    if (intersects.length > 0) {
        // 点击了照片，进入全屏模式
        const clickedPhoto = intersects[0].object;
        showPhotoDetail(clickedPhoto);
    }
}
```

---

## 六、性能优化策略

### 6.1 渲染优化

#### 视锥剔除（Frustum Culling）
- 只渲染相机视野内的对象
- Three.js自动处理

#### LOD（细节层次）
```javascript
// 根据距离使用不同精度的模型
function updateLOD(camera, photoFrame) {
    const distance = camera.position.distanceTo(photoFrame.position);
    
    if (distance > 20) {
        // 远距离：使用低分辨率纹理
        photoFrame.material.map = lowResTexture;
    } else {
        // 近距离：使用高分辨率纹理
        photoFrame.material.map = highResTexture;
    }
}
```

#### 实例化渲染（InstancedMesh）
```javascript
// 相同相框使用实例化渲染
const frameGeometry = new THREE.BoxGeometry(2.5, 2, 0.1);
const frameMaterial = new THREE.MeshStandardMaterial();
const frames = new THREE.InstancedMesh(frameGeometry, frameMaterial, photoCount);

// 设置每个实例的位置和旋转
for (let i = 0; i < photoCount; i++) {
    const matrix = new THREE.Matrix4();
    matrix.setPosition(positions[i].x, positions[i].y, positions[i].z);
    frames.setMatrixAt(i, matrix);
}
```

### 6.2 纹理优化

#### 纹理压缩
- 使用压缩纹理格式（如KTX2）
- 根据设备性能选择纹理质量

#### 渐进式加载
```javascript
// 先加载低分辨率，再加载高分辨率
function loadPhotoTexture(photoUrl, frame) {
    // 1. 先加载低分辨率版本
    const lowResUrl = getLowResUrl(photoUrl);
    textureLoader.load(lowResUrl, (texture) => {
        frame.material.map = texture;
        frame.material.needsUpdate = true;
    });
    
    // 2. 再加载高分辨率版本
    const highResUrl = getHighResUrl(photoUrl);
    textureLoader.load(highResUrl, (texture) => {
        frame.material.map = texture;
        frame.material.needsUpdate = true;
    });
}
```

### 6.3 内存管理

#### 纹理释放
```javascript
// 删除照片时释放纹理
function removePhoto(frame) {
    if (frame.material.map) {
        frame.material.map.dispose();
    }
    frame.material.dispose();
    frame.geometry.dispose();
    scene.remove(frame);
}
```

---

## 七、移动端适配

### 7.1 性能降级

#### 检测设备性能
```javascript
function detectDevicePerformance() {
    const isMobile = /Mobile|Android|iPhone/i.test(navigator.userAgent);
    const gpuTier = getGPUTier();  // 检测GPU性能
    
    return {
        isMobile,
        gpuTier,
        shouldUseLowQuality: isMobile || gpuTier < 2
    };
}
```

#### 质量设置
```javascript
const qualitySettings = {
    high: {
        textureSize: 2048,
        shadowMapSize: 2048,
        antialias: true
    },
    medium: {
        textureSize: 1024,
        shadowMapSize: 1024,
        antialias: true
    },
    low: {
        textureSize: 512,
        shadowMapSize: 512,
        antialias: false
    }
};
```

### 7.2 触摸优化

#### 触摸控制
```javascript
// 移动端触摸事件处理
let touchStartX, touchStartY;

canvas.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
});

canvas.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1) {
        // 单指：旋转
        const deltaX = e.touches[0].clientX - touchStartX;
        const deltaY = e.touches[0].clientY - touchStartY;
        controls.rotateCamera(deltaX, deltaY);
    } else if (e.touches.length === 2) {
        // 双指：缩放
        const distance = getTouchDistance(e.touches);
        controls.zoom(distance);
    }
});
```

---

## 八、兼容性处理

### 8.1 WebGL检测

```javascript
function checkWebGLSupport() {
    try {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        
        if (!gl) {
            return false;
        }
        
        // 检查必要的扩展
        const extensions = [
            'OES_texture_float',
            'OES_element_index_uint'
        ];
        
        for (const ext of extensions) {
            if (!gl.getExtension(ext)) {
                console.warn(`Extension ${ext} not supported`);
            }
        }
        
        return true;
    } catch (e) {
        return false;
    }
}
```

### 8.2 降级方案

```javascript
// 不支持WebGL时自动切换到传统模式
if (!checkWebGLSupport()) {
    console.warn('WebGL not supported, switching to traditional mode');
    showTraditionalGallery();
} else {
    init3DGallery();
}
```

---

## 九、实现步骤

### 步骤1：基础设置
1. 引入Three.js库
2. 创建WebGL渲染器
3. 设置场景和相机
4. 添加基础光照

### 步骤2：场景构建
1. 创建地面
2. 创建墙面（4面墙）
3. 设置场景布局

### 步骤3：照片展示
1. 从存储读取照片数据
2. 创建3D相框
3. 加载照片纹理
4. 计算照片位置
5. 将照片添加到场景

### 步骤4：交互控制
1. 集成OrbitControls
2. 实现点击检测
3. 实现照片点击交互
4. 优化控制体验

### 步骤5：优化和测试
1. 性能优化
2. 移动端适配
3. 兼容性测试
4. 用户体验优化

---

## 十、总结

3D展览馆功能是本系统的核心亮点，通过WebGL和Three.js技术，为用户提供沉浸式的展览浏览体验。实现时需要注意：

1. **性能优先**：大量照片时的渲染性能
2. **用户体验**：流畅的交互控制
3. **兼容性**：WebGL支持和降级方案
4. **移动端**：触摸控制和性能优化

通过合理的架构设计和优化策略，可以创建一个既美观又流畅的3D虚拟展览馆。











